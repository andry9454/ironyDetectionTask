"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var React = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var types = {
  ascii: "asciimath",
  tex: "tex"
};

var Node =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2.default)(Node, _React$Component);

  function Node(props) {
    var _this;

    (0, _classCallCheck2.default)(this, Node);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Node).call(this, props));
    _this.nodeRef = React.createRef();
    (0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)).typeset = _this.typeset;
    return _this;
  }
  /**
   * Render the math once the node is mounted
   */


  (0, _createClass2.default)(Node, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.typeset();
    }
    /**
     * Update the jax, force update if the display mode changed
     */

  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var forceUpdate = prevProps.inline !== this.props.inline || prevProps.children !== this.props.children;
      this.typeset(forceUpdate);
    }
    /**
     * Prevent update when the source has not changed
     */

  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState, nextContext) {
      return nextProps.children !== this.props.children || nextProps.inline !== this.props.inline;
    }
    /**
     * Clear the math when unmounting the node
     */

  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clear();
    }
    /**
     * Clear the jax
     */

  }, {
    key: "clear",
    value: function clear() {
      var MathJax = this.context.MathJax;

      if (!this.script) {
        return;
      }

      var jax = MathJax.Hub.getJaxFor(this.script);

      if (jax) {
        jax.Remove();
      }
    }
    /**
     * Update math in the node
     * @param { Boolean } forceUpdate
     */

  }, {
    key: "typeset",
    value: function typeset() {
      var forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var MathJax = this.context.MathJax;

      if (!MathJax) {
        throw Error("Could not find MathJax while attempting typeset! It's likely the MathJax script hasn't been loaded or MathJax.Context is not in the hierarchy");
      }

      var text = this.props.children;

      if (forceUpdate) {
        this.clear();
      }

      if (forceUpdate || !this.script) {
        this.setScriptText(text);
      }

      MathJax.Hub.Queue(MathJax.Hub.Reprocess(this.script, this.props.onRender));
    }
    /**
     * Create a script
     * @param { String } text
     */

  }, {
    key: "setScriptText",
    value: function setScriptText(text) {
      var inline = this.props.inline;
      var type = types[this.context.input];

      if (!this.script) {
        this.script = document.createElement("script");
        this.script.type = "math/".concat(type, "; ").concat(inline ? "" : "mode=display");
        this.nodeRef.current.appendChild(this.script);
      } // It _should_ be defined at this point, we'll just return at this point now


      if (!this.script) {
        return;
      }

      if ("text" in this.script) {
        // IE8, etc
        this.script.text = text;
      } else {
        this.script.textContent = text;
      }
    }
  }, {
    key: "render",
    value: function render() {
      return React.createElement("span", {
        ref: this.nodeRef
      });
    }
  }]);
  return Node;
}(React.Component);

(0, _defineProperty2.default)(Node, "defaultProps", {
  inline: false,
  onRender: null
});
Node.contextTypes = {
  MathJax: _propTypes.default.object,
  input: _propTypes.default.string
};
var _default = Node;
exports.default = _default;